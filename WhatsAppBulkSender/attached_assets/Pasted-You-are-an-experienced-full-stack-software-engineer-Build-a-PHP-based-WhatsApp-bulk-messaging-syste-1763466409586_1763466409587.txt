You are an experienced full-stack software engineer. Build a PHP-based WhatsApp bulk messaging system (web app) exactly according to the workflow and constraints described below. Use modern best practices, good security, and production-ready design. Prefer Laravel (PHP) for backend (or clearly justify another PHP framework), MySQL (or MariaDB) for DB, and a modern frontend framework (Vue 3 / React) + Tailwind CSS for responsive UI. Use a queue worker for bulk sending (Laravel Queue / Redis / RabbitMQ). Provide complete source, DB migrations, tests, Docker files, and deployment notes.

1) High-level requirements (must)

Two roles: Admin and User.

Login page with two options: “Login as Admin” and “Login as User”.

Admin dashboard: greeting based on time + four main options:

Manage Businesses (CRUD)

Fields: id (PK, auto), business_name, business_token, phone_id, waba_id, created_at, updated_at, status (active/inactive).

Manage Users (CRUD)

Fields: id (PK), name, email (unique), password (hashed), role (user/admin), created_by_admin_id, created_at, updated_at.

Manage Tasks (CRUD + Assign)

Task fields: id, title, assigned_user_id (FK users), business_id (FK businesses) — these two are mandatory when creating a task, description, status (pending/ongoing/completed), created_by, created_at, updated_at.

View Report

Get reports by task id or task title: total delivered, total seen, total replies (per task).

Admin can view reports for all users and all tasks.

User dashboard: greeting + three main options:

Assigned Task — list tasks assigned to the logged-in user (only their tasks). Can mark as complete/partial etc.

Send Message (core feature) — bulk messaging UI:

Input: Image Drive link (URL), recipients CSV/Excel upload (phone numbers), title, message body.

Message composition order: Image → Title → Message body (as user-visible).

Ensure the messages are sent using credentials (business_token, phone_id, waba_id) of the Business that admin assigned the task to.

The UI must validate mandatory fields and show progress.

History — user can view only their past messages & view report for their tasks (delivered, seen, replies).

Admin can view all reports for all users/tasks. Users only their assigned tasks’ reports.

UI: modern, professional, responsive (desktop + mobile perfect). Use Tailwind or modern CSS. Provide wireframes or component list.

2) Database schema (provide migrations + SQL)

Provide SQL and framework migrations for tables:

users (id, name, email, password_hash, role, created_at, updated_at)

businesses (id, business_name, business_token, phone_id, waba_id, status, created_at, updated_at)

tasks (id, title, description, assigned_user_id FK, business_id FK, status, created_by, created_at, updated_at)

messages (id, task_id FK, business_id FK, user_id FK (sender), media_url, title, body, total_recipients, created_at, status)

message_recipients (id, message_id FK, phone_number, status (queued/sent/delivered/seen/failed), meta (json), reply_text, delivered_at, seen_at, reply_at)

logs or audit_logs (id, user_id, action, object_type, object_id, details json, created_at)

jobs (if using DB queue) or rely on queue system.

Include indices and foreign key constraints. Provide sample migration files.

3) Backend responsibilities (endpoints + behavior)

Create REST API endpoints (and GraphQL optional) with clear contracts:

Authentication:

POST /api/auth/login — body {email, password, role?} → returns JWT or session cookie.

POST /api/auth/logout

Admin APIs:

GET /api/admin/businesses

POST /api/admin/businesses — create business.

GET /api/admin/businesses/{id}

PUT /api/admin/businesses/{id}

DELETE /api/admin/businesses/{id}

GET /api/admin/users

POST /api/admin/users — create user (email, name, password, role)

GET /api/admin/users/{id}

PUT /api/admin/users/{id}

DELETE /api/admin/users/{id}

GET /api/admin/tasks

POST /api/admin/tasks — requires title, assigned_user_id, business_id (mandatory)

PUT /api/admin/tasks/{id}

DELETE /api/admin/tasks/{id}

GET /api/admin/reports?task_id=&task_title= — returns aggregated stats (delivered, seen, replies) per task. Include pagination.

User APIs:

GET /api/user/tasks/assigned

PUT /api/user/tasks/{id}/status — mark complete/in-progress.

Message sending flow:

POST /api/messages — body:

task_id (optional but recommended),

business_id (must belong to the task or selected by admin assignment),

media_url (image public URL),

recipients_file (CSV/XLSX uploaded file),

title, body.

On receiving request: validate business ownership and required fields, parse CSV, sanitize numbers (E.164), deduplicate numbers, verify limits, create messages row, create message_recipients rows with status queued, then push job to queue for processing (bulk sending worker).

Return immediate response with message_id and queued count.

Status callbacks:

Implement webhook endpoint to receive delivery/read/reply events from Meta (if supported):

POST /api/webhooks/meta — validate signature, update message_recipients status (delivered/seen) and increment counts.

Provide robust retry / idempotency for webhooks.

Bulk sender worker:

Read recipients in batches (configurable batch size, e.g., 50-100), obey Meta rate limits.

Use official Meta WhatsApp Business Cloud API endpoints — send media + text messages using the correct business_token and phone_id.

Retry policy (3 retries with exponential backoff) for transient errors; log permanent failures.

Respect concurrency per business to avoid token collisions.

Reports APIs:

GET /api/reports/task/{task_id} → aggregated numbers, recipient-level data (with pagination).

GET /api/messages/{message_id}/recipients → list and status.

Security:

All admin routes require admin role. User routes require authenticated user.

Passwords hashed with bcrypt/argon2.

Use HTTPS, CSRF protection, input sanitization, rate-limiting.

Store tokens encrypted at rest (use framework encryption).

File upload validation (type, size), scan for potential threats.

4) Frontend (UI/UX)

Pages/components:

Login page (admin/user toggle)

Admin dashboard (greeting based on server time + cards for 4 features)

Businesses CRUD page (table + modal for create/edit)

Users CRUD page (table + create modal)

Tasks page (list + create/edit assign modal)

Reports page (filter by task id/title + export CSV)

User dashboard (Assigned tasks list + Send Message + History)

Send Message UX:

File upload component (CSV/XLSX) → preview parsed numbers and show errors.

Media URL input with preview (validate accessible image).

Title and body inputs with WYSIWYG minimal (or textarea).

Option to schedule send time (optional; if present, store scheduled job).

Progress UI showing queued/sent/delivered/failed counts in real time (via polling or WebSocket).

History and Message detail page (recipient-level statuses).

Responsive layout; match modern look (header, sidebar for desktop, hamburger for mobile). Provide simple wireframe images or ASCII wireframe and component list.

Accessibility & UX:

Form validation inline, friendly error messages.

Bulk upload size limits shown before upload.

Show estimated time and batch progress (based on count/batch size).

Allow CSV template download.

5) Integration with Meta WhatsApp Business API (requirements)

Use provided business_token, phone_id, waba_id for each business record.

For media, send as media_url (must be public). Upload approach: either use remote URL or first upload media to Meta (if required) and reuse returned media id.

Implement webhook verification and signature checking.

Handle message templates requirement: if sending notifications outside 24h session, ensure templates are used OR detect and handle template errors gracefully (log and surface to user).

Handle rate-limits & 429s: implement exponential backoff and throttling per business token.

6) Operational requirements

Queue & Worker: use Laravel Queue with Redis or database queue; provide supervisor config or systemd service for workers.

Logs: structured logging; store errors and delivery events.

Monitoring: expose basic health endpoints; optional Prometheus metrics.

Export: Reports export to CSV or Excel.

Backup: DB backup instructions.

Provide Dockerfile(s) and docker-compose.yml for dev + production example.

7) Tests, QA & acceptance criteria

Unit tests for core logic: auth, business CRUD, task creation, CSV parsing, number normalization, queue job logic.

Integration tests: simulate sending (mock Meta API) for success and failure flows, webhook handling.

End-to-end tests: basic flows (admin create business, admin create user, admin assign task, user upload recipients, worker sends).

Acceptance criteria (must pass):

Admin can create 2 businesses and assign tasks to users; user sees only their tasks.

Uploading a CSV with valid numbers enqueues a message job and worker simulates sending messages via stubbed Meta API and updates statuses.

Reports show correct counts (delivered, seen, replies).

Permissions: user cannot access admin endpoints; admin can view all reports.

UI responsive on mobile + desktop.

8) Deliverables & repo structure

Full source code (backend + frontend) in a git repo with clear README.

README: project overview, architecture diagram, env variables, installation, running locally, running tests, deployment steps.

docker-compose.yml for dev. Dockerfile for app image.

DB migrations and seeders (sample admin user, sample business).

Postman collection or OpenAPI spec for APIs.

Wireframes (PNG or simple images) and screenshots.

Unit + integration tests with coverage report.

Deployment guide for a typical VPS and for cloud (optional: Forge / DigitalOcean / AWS ECS).

Suggested repo structure:

/backend (Laravel)
  /app
  /database
  /routes
  /tests
/frontend (Vue or React)
  /src
  /components
  /pages
docker-compose.yml
README.md
postman_collection.json

9) Non-functional requirements & security checklist

Use HTTPS for all endpoints.

Use environment variables for tokens and secrets.

Encrypt business tokens in DB.

Audit logs for business actions.

Rate-limiting per API route.

Password policy + password reset flow (email).

Role-based access control.

Input validation & sanitization.

CSRF and CORS config.

10) Implementation hints & decisions (preferred)

PHP framework: Laravel 10+ (because of built-in queues, jobs, notifications, jobs, encryption, Passport/Sanctum).

Frontend: Vue 3 + Vite + Tailwind CSS (or React + Tailwind).

Queue: Redis + php artisan queue:work (or RabbitMQ).

Use Laravel Notifications for delivery events abstraction.

Mock Meta API in tests; implement an adapter pattern MetaWhatsAppAdapter to keep integration testable.

For CSV parsing: use league/csv or maatwebsite/excel.

Persist only phone numbers and statuses; do not store message bodies longer than necessary (trim logs).

Use WebSockets (Pusher / Laravel Echo) for real-time update (optional but preferred).

11) Extra: sample SQL migration (example)

Provide DB migration SQL for businesses and tasks. Example:

CREATE TABLE businesses (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  business_name VARCHAR(255) NOT NULL,
  business_token TEXT NOT NULL,
  phone_id VARCHAR(100),
  waba_id VARCHAR(100),
  status ENUM('active','inactive') DEFAULT 'active',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
CREATE TABLE tasks (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  assigned_user_id BIGINT NOT NULL,
  business_id BIGINT NOT NULL,
  status ENUM('pending','ongoing','completed') DEFAULT 'pending',
  created_by BIGINT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (assigned_user_id) REFERENCES users(id),
  FOREIGN KEY (business_id) REFERENCES businesses(id)
);

12) Last mile: step-by-step milestones for agent to implement

Setup repo, Laravel app, basic auth (Sanctum/JWT).

Design DB migrations & run them.

Implement Admin CRUD APIs (business, users) + UI pages.

Implement Tasks CRUD + assign logic + UI.

Implement CSV upload parsing, normalization, message & recipient records.

Implement queue worker for sending with Meta adapter (mock first).

Implement webhook endpoint for delivery/read/reply updates.

Implement reports endpoints + UI.

Tests + CI.

Dockerize + docs + deployment guide.

13) Provide sample acceptance test (automated)

Create admin user

Admin creates business with token, phone_id, waba_id

Admin creates user and assigns task to business

User logs in, uploads CSV of 120 numbers, image URL, title, message

Job enqueues and worker processes in batches, calls Meta adapter (mock) and updates statuses

Webhook call simulates delivered/seen/reply for some recipients; reports reflect numbers

14) Output expected from AI Agent to handover to you

Working repo (zip or github link)

README with run & deploy steps

Postman/OpenAPI

DB migration SQL

Wireframes/screenshots

Tests & coverage

Docker compose

Tone to use in UI & messages

Professional, crisp, friendly.

Hindi/English mix OK for UI labels if you prefer; but default to English for internationalization and clarity. Provide i18n keys.

Final note to the AI Agent:

Be conservative with rate-limits and error handling when interacting with Meta's API. Implement an adapter layer so switching providers or tokens is straightforward. If any requirement is unclear, make a safe design choice and document it in the README rather than asking for new clarifications.